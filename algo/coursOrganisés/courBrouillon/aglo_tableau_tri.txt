exo 7.1 

algo tab 
var tab(1:N) : tab d'entiers
	i,n : entier
debut
done:= Faux 
i:=2
Repeter
		Si tab(i) != tabA(i-1)+1  alors done:= vrai
		i++; 
		FinSi
		jusqu'a (done:= vrai ou i:=n)
		Si done alors 
			ecrire ("consécutifs")
			sinon ecrire ("non consecutifs")
		FinSi
	FinPour
Fin 


______________________________________________________________________________

exo 7.2 

algo tab
var tab(1:N) : tab d'entiers
	i, : entier 

debut 
	done:= Faux 
		tant que done= Faux faire  
			Pour i:= 1 à N- 1 faire
					Si (tab(i)) < (tab(i+1)) alors
						temp := tab(i)
						tab (i) := tab(i+1)
						tab(i+1) := temp
						done:= Faux
					FinSi
				FinPour
			FinPour
		Fintantque
		done:= Vrai 
Fin


CORRECTION  
	
Tri par selection/ insertion :

	algo tab
	var tab(1:N) : tab d'entiers
		i,min,pos,temp, N : entier 
	
	Pour i:= 1 à N- 1 faire
		min:= tab(i); pos:= i
		pour j:=i+1 à N-1 faire
			Si (tab(j)) < min) alors
			min:= tab (j); pos:= j;
			FinSi
		FinPour
			temp := tab(i)
			tab (i) :=  tab(pos)
			tab(pos) := temp
			FinSi
	FinPour
	Fin



Tri à bulles :

1. tab(i) < tab(i+1) 
2. Flag

algo 
var tab (1:n) entiers;
		n,i : entier
		YaPermute : booleen;

YaPermute := Vrai
debut
	Tantque (yapermute) faire
	yapermute:= Faux
	Pour i:=1 a n-1							/*On parcour le tableau*/
		si (tab(i)< tab(i+1))				/*En comparant la valeur actuelle avec la suivante*/
			temp:= tab(i);					/*Si elle est plus petite, alors on percute*/
			tab(i):= tab(i+1);
			tab(i+1):= temp;
			yapermute:= vrai				/*Il y a eu permutation*/
		FinSi
	FinPour
Fin
	
	

______________________________________________________________________________

exo 7.3 

algo inverser;

var tab(1:N) : entiers 							1	2	3	4	
	i,n temp : entier							12	15	9	10		
													
debut 											12	15	10
i:=0; 
Repeter
	temp := (tab(i+1))    
	tab(i+1):= Tab(n-i)  ; 
	tab(n-i):= temp;
	i++;
jusqu'à ((i+1) >= (n-i))
Fin

OU 

debut 							debut
pour(i=1; i<n; i++)				Pour (i=1; i=<n/2; i++)
 temp:= tab(i);						temp:= tab(i);
 tab(i):= tab(n);					tab(i):= table(n-i);
 tab(n):= temp;						tab(n-i):= temp;
Finpour							FinPour
Fin 							Fin	
____________________________________________________________________________

exo 7.4 

algo sup 

var tab(0:N) : entiers
	i : entier
	
debut
ecrire ("quel valeur supprimer?")  
lire (X) 
Pour i:= X à N-1
	tab(i):= tab(i+1)
redim(tab(n-1))
FinPour
fin

OU

debut
pour (i:=x, i<=n-1; i++) faire	
	tab(i):= tab(i+1)
FinPoour
redim (tab(n-1));
Fin 
	
______________________________________________________________________________

exo 7.5

exo 7.5
algo dico
var tab(1:n) : chaine de caractère
    sup, inf, comp : chaine de caractère
	
debut
Ecrire ("Entrez le mot")
lire (Mot)
indiceFinal:= N-1
indiceDepart:= 0

Fini := Faux
Tantque non Fini
    indiceMilieux:= (indiceFinal + indiceDepart)/2
        Si Mot < Dicto(indiceMilieux) alors
        indiceFinal:= indiceMilieux -1
        sinon indiceDepart:= indiceMilieux +1
        FinSi
        Si (Dico(indiceMilieux) < indiceDepart) ou (indiceFinal < indiceDepart) 
		Fini := vrai
FinTantque
Si Mot = Dicto(indiceMilieux) alors
ecrire "le mot existe"
sinon ecrire ("n'existe pas")
FinSi
Fin

CORRECTION

lire (mot);									Pour (i:= 1 à 9) faire	
i:=1; trouve := faux;							Si (mot= (dict(1))
repeter 											alors ecrire ("trouver");
Si(mot = Dict(9/2))								i:=9
	alors trouve := Vrai 					FinPour
Sinon Si mot < Dict (4/2)
jusqu'a trouve;


algo dictionnaire
var dicto(1:n) : tableau de chaines de caracteres,
	trouve : booléen,
	mot : chaine de caractère
	indiceDepart, indiceFinal, indiceMilieux:= (indiceDepart + indiceFinal)/2 : entier;
	 
	
debut 
	trouve := faux														1	2	3	4	5	6
	lire(mot);															b	c 	f 	h 	o 	y
	indiceDepart:= 1; indiceFinal:= n; indiceMilieux;
	repeter
		indiceMilieux:= (indiceDepart + indiceFinal)/2
		si (mot > dicto(indiceMilieux))
			alors									
			indiceDepart := indiceMilieux +1				// maj l'indice de depart (indiceDepart = n/2 +1) 	6/2+1=4
															// indice final max = n								6
			Sinon si (mot < dicto(n/2))
				alors								
															// maj indice de depart (indiceDepart =1)			[1:4]
				indiceFinal := indiceMilieux -1;			// indice final ( =n/2-1)							6/2-1 2
				sinon 
					trouve :=vrai 
				fin_si
		fin_si
		
	jusqu'a (trouve := vrai ou indiceDepart >n ou indiceFinal <= 0)

	si (trouve) alors ecrire ("mot trouvé");
	sinon ecrire ("mot non trouvé");
fin


_____________________________________________________________________________

